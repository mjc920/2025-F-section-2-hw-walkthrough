<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bright Snake — Modern</title>

  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;600&family=Orbitron:wght@400;700&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg1: #4b9fff;
      --bg2: #6cf7a7;
      --glass: rgba(255,255,255,0.18);
      --panel: rgba(255,255,255,0.06);
      --accent: #ffdd57;
      --apple: #ff4b4b;
      --snake: #28e07b;
      --snake-dark: #00b35a;
    }

    html,body{height:100%;margin:0;font-family:Montserrat,system-ui,-apple-system,Segoe UI,Roboto,Arial;}
    body{
      display:flex;
      align-items:center;
      justify-content:center;
      padding:24px;
      background: linear-gradient(135deg,var(--bg1),var(--bg2));
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    .container{
      width: min(680px, 96vw);
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
      border-radius:14px;
      padding:20px;
      box-shadow: 0 12px 40px rgba(0,0,0,0.25);
      display:grid;
      grid-template-columns: 1fr 240px;
      gap:18px;
      align-items:start;
      backdrop-filter: blur(6px);
      border: 1px solid rgba(255,255,255,0.08);
    }

    /* left: game board */
    .board-wrap{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:12px;
    }

    canvas{
      width:100%;
      max-width:480px;
      height:auto;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:10px;
      border: 3px solid rgba(255,255,255,0.08);
      box-shadow: 0 6px 18px rgba(0,0,0,0.25);
      display:block;
    }

    .controls-touch{
      display:flex;
      gap:8px;
      align-items:center;
      justify-content:center;
      flex-wrap:wrap;
      margin-top:4px;
    }
    .btn-touch{
      width:56px;
      height:56px;
      border-radius:10px;
      background:var(--glass);
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:700;
      color:white;
      user-select:none;
      border: 1px solid rgba(255,255,255,0.06);
      box-shadow: 0 6px 14px rgba(0,0,0,0.18);
      -webkit-tap-highlight-color: transparent;
    }
    .hint{
      color: rgba(255,255,255,0.92);
      font-size:14px;
      text-align:center;
    }

    /* right: panel */
    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:10px;
      padding:14px;
      border: 1px solid rgba(255,255,255,0.06);
      color: #fff;
    }
    .title{
      font-family: 'Orbitron', sans-serif;
      font-weight:700;
      color:var(--accent);
      font-size:20px;
      letter-spacing:1px;
      margin:0 0 8px 0;
    }
    .meta{ font-size:14px; color: #eafff0; margin-bottom:12px; }

    .stat{
      display:flex;
      justify-content:space-between;
      padding:8px 10px;
      background: rgba(0,0,0,0.06);
      border-radius:8px;
      margin-bottom:8px;
      font-weight:600;
    }

    .row{ display:flex; gap:8px; flex-direction:column; }

    .actions{ display:flex; gap:8px; margin-top:8px; flex-wrap:wrap; }
    .btn{
      padding:10px 12px;
      border-radius:8px;
      background:var(--panel);
      border:1px solid rgba(255,255,255,0.04);
      color:white;
      cursor:pointer;
      font-weight:600;
    }
    .btn:active{ transform:translateY(1px); }

    .small{ font-size:13px; color:#e9fff1; opacity:0.95; margin-top:10px; }

    @media (max-width:820px){
      .container{ grid-template-columns: 1fr; }
      .panel{ order:2; }
    }
  </style>
</head>
<body>
  <div class="container" role="application" aria-label="Snake game">
    <div class="board-wrap">
      <canvas id="game" width="480" height="480" aria-label="Game board"></canvas>
      <div class="controls-touch" aria-hidden="false">
        <div class="btn-touch" id="up">↑</div>
        <div style="width:8px"></div>
        <div class="btn-touch" id="left">←</div>
        <div class="btn-touch" id="down">↓</div>
        <div class="btn-touch" id="right">→</div>
      </div>
      <div class="hint">Controls: Arrow keys or touch. Space = Pause, R = Restart.</div>
    </div>

    <aside class="panel" aria-labelledby="panelTitle">
      <h3 id="panelTitle" class="title">Bright Snake</h3>
      <div class="meta">Eat apples, grow longer, and beat your high score!</div>

      <div class="row">
        <div class="stat"><span>Score</span><span id="score">0</span></div>
        <div class="stat"><span>High Score</span><span id="highScore">0</span></div>
        <div class="stat"><span>Speed</span><span id="speedLabel">Normal</span></div>
      </div>

      <div class="actions" role="toolbar" aria-label="Game actions">
        <button class="btn" id="btnStart">Start</button>
        <button class="btn" id="btnPause">Pause</button>
        <button class="btn" id="btnRestart">Restart</button>
        <button class="btn" id="btnWalls">Walls: On</button>
      </div>

      <div class="small">
        Tip: The snake cannot reverse direction instantly. Speed increases slightly every 3 apples.
      </div>
    </aside>
  </div>

  <script>
    // --- CONFIG ---
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const CELL = 24;                      // size of a cell in pixels
    const COLS = canvas.width / CELL;     // 20
    const ROWS = canvas.height / CELL;    // 20

    // Game state
    let snake = [];                       // array of {x,y}
    let dir = { x: 1, y: 0 };             // current movement direction (grid units)
    let nextDir = { x: 1, y: 0 };         // buffered direction from input
    let food = null;
    let score = 0;
    let highScore = parseInt(localStorage.getItem('snakeHigh') || '0', 10) || 0;
    let speed = 120;                      // ms per tick
    let baseSpeed = 120;
    let running = false;
    let wallsOn = true;
    let tickTimer = null;

    // DOM
    const scoreEl = document.getElementById('score');
    const highEl = document.getElementById('highScore');
    const speedLabel = document.getElementById('speedLabel');
    const btnStart = document.getElementById('btnStart');
    const btnPause = document.getElementById('btnPause');
    const btnRestart = document.getElementById('btnRestart');
    const btnWalls = document.getElementById('btnWalls');

    // Touch controls
    document.getElementById('up').addEventListener('pointerdown', () => setDirection(0,-1));
    document.getElementById('down').addEventListener('pointerdown', () => setDirection(0,1));
    document.getElementById('left').addEventListener('pointerdown', () => setDirection(-1,0));
    document.getElementById('right').addEventListener('pointerdown', () => setDirection(1,0));

    // Keyboard controls
    window.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowUp') setDirection(0, -1);
      else if (e.key === 'ArrowDown') setDirection(0, 1);
      else if (e.key === 'ArrowLeft') setDirection(-1, 0);
      else if (e.key === 'ArrowRight') setDirection(1, 0);
      else if (e.key === ' '){ // space = pause/unpause
        e.preventDefault();
        togglePause();
      } else if (e.key.toLowerCase() === 'r'){ restart(); }
    });

    btnStart.addEventListener('click', start);
    btnPause.addEventListener('click', togglePause);
    btnRestart.addEventListener('click', restart);
    btnWalls.addEventListener('click', () => {
      wallsOn = !wallsOn;
      btnWalls.textContent = 'Walls: ' + (wallsOn ? 'On' : 'Off');
    });

    // initialize UI
    highEl.textContent = highScore;

    // Utilities
    function randInt(max){ return Math.floor(Math.random() * max); }

    function initGame(){
      snake = [];
      const startX = Math.floor(COLS / 2);
      const startY = Math.floor(ROWS / 2);
      for (let i = 0; i < 4; i++){
        snake.push({ x: startX - i, y: startY });
      }
      dir = { x: 1, y: 0 };
      nextDir = { x: 1, y: 0 };
      score = 0;
      speed = baseSpeed;
      running = false;
      updateUI();
      spawnFood();
      draw();
    }

    function spawnFood(){
      // spawn in a free cell (not on snake)
      let tries = 0;
      while (tries < 1000){
        const fx = randInt(COLS);
        const fy = randInt(ROWS);
        if (!snake.some(p => p.x === fx && p.y === fy)){
          food = { x: fx, y: fy };
          return;
        }
        tries++;
      }
      // fallback if something odd
      food = { x: 0, y: 0 };
    }

    function setDirection(x,y){
      // Prevent reversing: nextDir cannot be exact opposite of current dir
      if (x === -dir.x && y === -dir.y) return;
      nextDir = { x, y };
      // If not running, start moving on first input
      if (!running) start();
    }

    function start(){
      if (running) return;
      running = true;
      if (tickTimer) clearInterval(tickTimer);
      tickTimer = setInterval(tick, speed);
      updateUI();
    }

    function togglePause(){
      running = !running;
      if (running){
        tickTimer = setInterval(tick, speed);
        btnPause.textContent = 'Pause';
      } else {
        clearInterval(tickTimer);
        btnPause.textContent = 'Resume';
      }
      updateUI();
    }

    function restart(){
      if (tickTimer) clearInterval(tickTimer);
      initGame();
      start();
    }

    function tick(){
      // apply buffered direction
      if (nextDir.x !== dir.x || nextDir.y !== dir.y){
        // only allow change if not reversing into self
        if (!(nextDir.x === -dir.x && nextDir.y === -dir.y)){
          dir = { ...nextDir };
        }
      }

      // compute new head
      const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };

      // wall behavior
      if (wallsOn){
        if (head.x < 0 || head.x >= COLS || head.y < 0 || head.y >= ROWS){
          gameOver();
          return;
        }
      } else {
        // wrap around
        if (head.x < 0) head.x = COLS - 1;
        if (head.x >= COLS) head.x = 0;
        if (head.y < 0) head.y = ROWS - 1;
        if (head.y >= ROWS) head.y = 0;
      }

      // self collision
      if (snake.some((p, i) => i !== 0 && p.x === head.x && p.y === head.y)){
        gameOver();
        return;
      }

      snake.unshift(head);

      // eat food?
      if (head.x === food.x && head.y === food.y){
        score++;
        // speed up every 3 points slightly
        if (score % 3 === 0 && speed > 40){
          speed = Math.max(40, Math.round(speed * 0.88));
          // restart interval with new speed
          if (running){
            clearInterval(tickTimer);
            tickTimer = setInterval(tick, speed);
          }
        }
        spawnFood();
      } else {
        // move forward (remove tail)
        snake.pop();
      }

      updateUI();
      draw();
    }

    function gameOver(){
      running = false;
      clearInterval(tickTimer);
      if (score > highScore){
        highScore = score;
        localStorage.setItem('snakeHigh', String(highScore));
      }
      // flash board or show quick animation - simple blink
      flashBoard(3, 140);
      updateUI();
    }

    function flashBoard(times, ms){
      let n = 0;
      const id = setInterval(() => {
        ctx.save();
        ctx.fillStyle = 'rgba(255,255,255,0.08)';
        ctx.fillRect(0,0,canvas.width, canvas.height);
        ctx.restore();
        n++;
        if (n >= times) clearInterval(id);
      }, ms);
    }

    function updateUI(){
      scoreEl.textContent = String(score);
      highEl.textContent = String(highScore);
      const speedName = speed >= 110 ? 'Slow' : (speed >= 75 ? 'Normal' : (speed >= 50 ? 'Fast' : 'Very Fast'));
      speedLabel.textContent = speedName;
      btnPause.textContent = running ? 'Pause' : 'Resume';
    }

    // DRAWING
    function drawGrid(){
      // subtle grid (optional)
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,0.03)';
      ctx.lineWidth = 1;
      for (let x = 0; x <= canvas.width; x += CELL){
        ctx.beginPath();
        ctx.moveTo(x + 0.5, 0);
        ctx.lineTo(x + 0.5, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y <= canvas.height; y += CELL){
        ctx.beginPath();
        ctx.moveTo(0, y + 0.5);
        ctx.lineTo(canvas.width, y + 0.5);
        ctx.stroke();
      }
      ctx.restore();
    }

    function draw(){
      // clear
      ctx.clearRect(0,0,canvas.width, canvas.height);

      // background glow
      const g = ctx.createLinearGradient(0,0,canvas.width, canvas.height);
      g.addColorStop(0, 'rgba(255,255,255,0.015)');
      g.addColorStop(1, 'rgba(0,0,0,0.03)');
      ctx.fillStyle = g;
      ctx.fillRect(0,0,canvas.width, canvas.height);

      // grid (subtle)
      drawGrid();

      // draw food (apple) with small shine
      if (food){
        const fx = food.x * CELL + CELL/2;
        const fy = food.y * CELL + CELL/2;
        const r = CELL/2 - 2;

        // apple body
        ctx.beginPath();
        ctx.fillStyle = 'rgba(255,75,75,1)';
        ctx.arc(fx, fy, r, 0, Math.PI*2);
        ctx.fill();
        // highlight
        ctx.beginPath();
        ctx.fillStyle = 'rgba(255,255,255,0.35)';
        ctx.ellipse(fx - r*0.3, fy - r*0.45, r*0.35, r*0.55, -0.6, 0, Math.PI*2);
        ctx.fill();
        // stem
        ctx.beginPath();
        ctx.strokeStyle = '#2d2d2d';
        ctx.lineWidth = 2;
        ctx.moveTo(fx + r*0.25, fy - r*0.6);
        ctx.lineTo(fx + r*0.05, fy - r*0.95);
        ctx.stroke();
      }

      // draw snake - gradient head + darker body
      for (let i = snake.length - 1; i >= 0; i--){
        const p = snake[i];
        const cx = p.x * CELL + CELL/2;
        const cy = p.y * CELL + CELL/2;
        const radius = CELL/2 - 2;

        if (i === 0){
          // head: brighter with pupil
          const grad = ctx.createRadialGradient(cx - radius*0.3, cy - radius*0.3, 2, cx, cy, radius);
          grad.addColorStop(0, '--unused');
          // use explicit colors (can't put CSS var directly into gradient stops reliably)
          grad.addColorStop(0, '#8bffb1');
          grad.addColorStop(1, '#00b35a');
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.arc(cx, cy, radius, 0, Math.PI*2);
          ctx.fill();

          // eye (simple)
          const eyeX = cx + (dir.x * radius*0.25) + (dir.y * -radius*0.2);
          const eyeY = cy + (dir.y * radius*0.25) + (dir.x * radius*0.2);
          ctx.beginPath();
          ctx.fillStyle = 'rgba(0,0,0,0.85)';
          ctx.ellipse(eyeX, eyeY, radius*0.18, radius*0.12, 0, 0, Math.PI*2);
          ctx.fill();
        } else {
          // body segments: darker green
          ctx.beginPath();
          ctx.fillStyle = '#2ddf86';
          ctx.arc(cx, cy, radius, 0, Math.PI*2);
          ctx.fill();
        }
      }
    }

    // initialize and show initial state
    initGame();
    draw();

    // ensure high score displayed immediately
    highEl.textContent = String(highScore);

    // make canvas crisp on high-DPI displays
    (function scaleCanvasForHiDPI(){
      const ratio = Math.max(1, window.devicePixelRatio || 1);
      if (ratio === 1) return;
      const w = canvas.width;
      const h = canvas.height;
      canvas.width = Math.floor(w * ratio);
      canvas.height = Math.floor(h * ratio);
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
    })();

    // start automatically for convenience
    // start();

    // expose minimal API in console for debugging
    window.snakeGame = {
      start, restart, togglePause, setDirection,
      getState: () => ({ score, highScore, speed, running, wallsOn, snakeLength: snake.length })
    };
  </script>
</body>
</html>
